---
{"dg-publish":true,"permalink":"/0-vault/1-notas-literais/anelo/latam-2023-3-1-section-3-logica-e-operacoes-de-bit-em-python/","tags":["python","ANELO"],"dgHomeLink":true,"dgShowLocalGraph":true,"dgShowFileTree":true,"dgEnableSearch":true,"noteIcon":""}
---

# LATAM 2023 - 3.1 Section 3 - Lógica e operações de bit em Python

## criado em: 
-  06-05-2023 - 18:05

### Conteúdo Relacionado
- notas: [[0 - VAULT/1 NOTAS LITERAIS/ANELO/LATAM 2023 - 3.1 Section 1 – Making decisions in Python\|LATAM 2023 - 3.1 Section 1 – Making decisions in Python]]
- [[alura python data science\|alura python data science]]
- tags: #python #ANELO 
- Fontes & Links: 
- extra - [curso alura PYTHON PARA DATA SCIENCE](https://cursos.alura.com.br/course/python-data-science-primeiros-passos/task/122394) 

---

# 3.3 Seção 3 - Lógica e operações de bit em Python

Nesta seção, você aprenderá sobre operadores lógicos e bit a bit no Python e conceitos como tabela verdade e deslocamento de bits.

[[0 - VAULT/1 NOTAS LITERAIS/ANELO/PYTHON cheat sheet de operadores logicos\|PYTHON cheat sheet de operadores logicos]]

3.3.1 Lógica do computador

Você já reparou que as condições que usamos até agora têm sido muito simples, para não dizer muito primitivas? As condições que usamos na vida real são muito mais complexas. Vamos analisar esta frase:

_Se tivermos tempo livre, e se o tempo estiver bom, vamos dar uma volta._

Usamos a conjunção and, o que significa que sair para passear depende do cumprimento simultâneo dessas duas condições. Na linguagem da lógica, essa conexão de condições é chamada de **conjunção**. E agora outro exemplo:

_Se você estiver no shopping Ou Estou no shopping, um de nós vai comprar um presente para a mãe._

A aparência da palavra or significa que a compra depende de pelo menos uma dessas condições. Na lógica, esse composto é chamado de **disjunção**.

É claro que o Python deve ter operadores para criar conjunções e disjunções. Sem eles, o poder expressivo da linguagem seria substancialmente enfraquecido. Eles são chamados de **operadores lógicos**.

# O operador _and_

Um operador de conjunção lógica em Python é a palavra _and_. É um **operador binário com uma prioridade menor do que a expressa pelos operadores de comparação**. Ela nos permite codificar condições complexas sem o uso de parênteses como este:

              `counter > 0 and value == 100`
              
               
          
              

      

O resultado fornecido pelo operador and pode ser determinado com base na **tabela verdade**.

Se considerarmos a conjunção de A and B, o conjunto de valores possíveis de argumentos e os valores correspondentes da conjunção têm a seguinte aparência:

![Pasted image 20230506181022.png](/img/user/0%20-%20VAULT/1%20NOTAS%20LITERAIS/ANELO/Pasted%20image%2020230506181022.png)

# O operador _or_

Um operador de disjunção é a palavra or. É um **operador binário com uma prioridade menor do que** and (assim como + em comparação com *).

  

Argumento A

Argumento B

A or B

False

False

False

False

True

True

True

False

True

True

True

True

  

# O operador _not_

Além disso, há outro operador que pode ser aplicado à construção de condições. É um **operador unário que executa uma negação** lógica. Sua operação é simples: transforma verdade em falsidade e falsidade em verdade.

Esse operador é escrito como a palavra not, e sua **prioridade é muito alta: o mesmo que os + e -** unários. Sua tabela de verdade é simples:

  

Argumento

not Argumento

False

True

True

False

Concluída 3.3.2 Expressões lógicas

3.3.2 Expressões lógicas

Vamos criar uma variável chamada var e atribuir 1 a ela. As condições a seguir são **equivalentes** aos pares:

              `# Exemplo 1:                                print(var > 0)                                print(not (var <= 0))                                                                # Exemplo 2:                                print(var != 0)                                print(not (var == 0))`
              
               
          
              

      

Você pode estar familiarizado com as[[ leis de De Morgan\| leis de De Morgan]]. Eles dizem que:

_A negação de uma conjunção é a disjunção das negações._

_A negação de uma disjunção é a conjunção das negações._

Vamos escrever o mesmo usando Python:

```python

not (p and q) == (not p) or (not q)                                not (p or q) == (not p) and (not q)
```
Observe como os parênteses foram usados para codificar as expressões - nós as colocamos lá para melhorar a legibilidade.

Devemos acrescentar que nenhum desses operadores de dois argumentos pode ser usado na forma abreviada conhecida como op=. Vale a pena lembrar essa exceção.

3.3.3 Valores lógicos vs. bits únicos

Os operadores lógicos recebem seus argumentos como um todo, independentemente de quantos bits eles contenham. Os operadores estão cientes apenas do valor: zero (quando todos os bits são redefinidos) significa False; diferente de zero (quando pelo menos um bit for definido) significa True.

O resultado de suas operações é um desses valores: False ou True. Isso significa que esse fragmento atribuirá o valor True à variável j se i não for zero; caso contrário, será False.

              `i = 1                                j = not not i`
              
               
          
              

      

Concluída 3.3.4 Operadores bit a bit

3.3.4 Operadores bit a bit

No entanto, existem quatro operadores que permitem **manipular bits únicos de dados**. Eles são chamados **de operadores bit a bit**.

Eles abrangem todas as operações que mencionamos anteriormente no contexto lógico e um operador adicional. Este é o operador xor (as **em exclusivo ou**) e é indicado como ^ (circunflexo).

Aqui estão todos eles:

-   & (e comercial) - conjunção bit a bit;
-   | (barra) - disjunção bit a bit;
-   ~ (til) - negação bit a bit;
-   ^ (circunflexo) ‒ bit a bit exclusivo ou (xor).

![Pasted image 20230506181611.png](/img/user/0%20-%20VAULT/1%20NOTAS%20LITERAIS/ANELO/Pasted%20image%2020230506181611.png)
![Pasted image 20230506181619.png](/img/user/0%20-%20VAULT/1%20NOTAS%20LITERAIS/ANELO/Pasted%20image%2020230506181619.png)

Vamos facilitar:

-   & requer exatamente dois 1 s para fornecer 1 como resultado;
-   | requer pelo menos um 1 para fornecer 1 como resultado;
-   ^ requer exatamente um 1 para fornecer 1 como resultado.

Vamos acrescentar uma observação importante: os argumentos desses operadores **devem ser números inteiros**; não devemos usar carros alegóricos aqui.

A diferença na operação dos operadores lógicos e de bit é importante: **os operadores lógicos não penetram no nível de bit de seu argumento**. Eles estão interessados apenas no valor inteiro final.

Os operadores de bit a bit são mais rigorosos: eles lidam **com cada bit separadamente**. Se assumirmos que a variável inteira ocupa 64 bits (o que é comum em sistemas de computadores modernos), você pode imaginar a operação bit a bit como uma avaliação de 64 vezes do operador lógico para cada par de bits dos argumentos. Essa analogia é obviamente imperfeita, pois no mundo real todas essas 64 operações são realizadas ao mesmo tempo (simultaneamente).

# Operações lógicas x operações de bit

Vamos agora mostrar um exemplo da diferença de operação entre as operações lógica e de bit. Vamos supor que as seguintes atribuições foram realizadas:

              `i = 15                                j = 22`
              
               
          
              

      

Se assumirmos que os números inteiros são armazenados com 32 bits, a imagem bit a bit das duas variáveis será a seguinte:

              `i: 00000000000000000000000000001111                                j: 00000000000000000000000000010110`
          
              

      

A tarefa é dada:

              `log = i and j`


              
               
          
              

      

Estamos lidando com uma conjunção lógica aqui. Vamos traçar o curso dos cálculos. Ambas as variáveis i e j não são zeros, então serão consideradas para representar True. Consultando a tabela de verdade para o operador and, podemos ver que o resultado será True. Nenhuma outra operação é executada.

              `log: True`
          
              

      

Agora, a operação bit a bit - aqui está:

              `bit = i & j`
              
               
          
              

      

O operador & operará com cada par de bits correspondentes separadamente, produzindo os valores dos bits relevantes do resultado. Portanto, o resultado será o seguinte:

i

00000000000000000000000000001111

j

00000000000000000000000000010110

bit = i & j

00000000000000000000000000000110

Esses bits correspondem ao valor inteiro de seis.

Vejamos os operadores de negação agora. Primeiro a lógica:

              `logneg = not i`
              
               
          
              

      

A variável logneg será definida como False - nada mais precisa ser feito.

A negação bit a bit é assim:

              `bitneg = ~i`
              
               
          
              

      

Pode ser um pouco surpreendente: o valor da variável bitneg é -16. Isso pode parecer estranho, mas não é. Se você quiser saber mais, consulte o sistema de números binários e as regras que regem os números de complemento de dois.

i

00000000000000000000000000001111

bitneg = ~i

11111111111111111111111111110000

  

Cada um desses operadores de dois argumentos pode ser usado de **forma abreviada**. Estes são os exemplos de notações equivalentes:

x = x & y

x &= y

x = x | y

x |= y

x = x ^ y

x ^= y

Concluída 3.3.5 Como lidamos com bits únicos?

3.3.5 Como lidamos com bits únicos?

Vamos mostrar para que você pode usar operadores bit a bit. Imagine que você é um desenvolvedor obrigado a escrever uma parte importante de um sistema operacional. Você foi informado de que pode usar uma variável atribuída da seguinte maneira:

              `flag_register = 0x1234`
              
               
          
              

      

A variável armazena as informações sobre vários aspectos da operação do sistema. **Cada bit da variável armazena um valor sim/não**. Você também foi informado de que apenas um desses bits é seu - o terceiro (lembre-se de que os bits são numerados de zero, e o número de bits zero é o mais baixo, enquanto o mais alto é o número 31). Os bits restantes não têm permissão para alterar, porque pretendem armazenar outros dados. Aqui está o seu bit marcado com a letra x:

              `flag_register = 0000000000000000000000000000x000`
              
               
          
              

      

Você pode se deparar com as seguintes tarefas:

1. **Verifique o estado do seu bit** - você quer descobrir o valor do seu bit; comparar a variável inteira com zero não fará nada, porque os bits restantes podem ter valores completamente imprevisíveis, mas você pode usar a seguinte propriedade de conjunção:

              `x & 1 = x                                x & 0 = 0`
              
               
          
              

      

Se você aplicar a operação & à variável flag_register junto com a seguinte imagem de bit:

              `00000000000000000000000000001000`
          
              

      

(observe o 1 na posição do bit), como resultado, você obtém uma das seguintes cadeias de bits:

-   00000000000000000000000000001000 se o bit foi definido como 1
-   00000000000000000000000000000000 se o bit foi redefinido para 0

Essa sequência de zeros e uns, cuja tarefa é capturar o valor ou alterar os bits selecionados, é chamada de **máscara de bit**.

Vamos construir uma máscara de bit para detectar o estado do bit. Deve apontar para o **terceiro bit**. Esse bit tem o peso de 23 = 8. Uma máscara adequada pode ser criada pela seguinte declaração:

              `the_mask = 8`
              
               
          
              

      

Você também pode fazer uma sequência de instruções, dependendo do estado do seu bit. Aqui está:

              `if flag_register & the_mask:                                    # Meu bit foi definida.                                else:                                    # Meu bit foi redefinido.`
              
               
          
              

      

2. **Redefinir seu bit** - você atribui um zero ao bit enquanto todos os outros bits devem permanecer inalterados; vamos usar a mesma propriedade da conjunção como antes, mas vamos usar uma máscara ligeiramente diferente, exatamente como abaixo:

              `11111111111111111111111111110111`
              
               
          
              

      

Observe que a máscara foi criada como resultado da negação de todos os bits da variável the_mask. Redefinir o bit é simples, e fica assim (escolha o que você mais gosta):

              `flag_register = flag_register & ~the_mask                                flag_register &= ~the_mask`
              
               
          
              

      

3. **Defina seu bit** - você atribui um 1 ao bit, enquanto todos os bits restantes devem permanecer inalterados; use a seguinte propriedade de disjunção:

              `x | 1 = 1                                x | 0 = x`
              
               
          
              

      

Você está pronto para definir o seu bit com uma das seguintes instruções:

              `flag_register = flag_register | the_mask                                flag_register |= the_mask`
              
               
          
              

      

4. **Negue sua parte** - você substitui um 1 por um 0 e um 0 por um 1. Você pode usar uma propriedade interessante do operador xor:

              `x ^ 1 = ~x                                x ^ 0 = x`
              
               
          
              

      

e negue sua parte com as seguintes instruções:

              `flag_register = flag_register ^ the_mask                                flag_register ^= the_mask`
              
               
          
              

      

Concluída 3.3.6 Deslocamento binário para a esquerda e deslocamento binário para a direita

3.3.6 Deslocamento binário para a esquerda e deslocamento binário para a direita

O Python oferece ainda outra operação relacionada a bits únicos: **deslocamento**. Isso é aplicado apenas a **valores inteiros**, e você não deve usar carros alegóricos como argumentos para ele.

Você já aplica essa operação com muita frequência e inconsciência. Como você multiplica um número por dez? Dê uma olhada:

12345 × 10 = 123450

Como você pode ver, **multiplicar por dez é, na verdade**, um deslocamento de todos os dígitos para a esquerda e preencher a lacuna resultante com zero.

Divisão por dez? Dê uma olhada:

12340 ÷ 10 = 1234

Dividir por dez nada mais é do que mudar os dígitos para a direita.

O mesmo tipo de operação é realizado pelo computador, mas com uma diferença: como dois é a base para números binários (não 10), **deslocar um valor um bit para a esquerda corresponde à multiplicação por dois;** respectivamente, **mudar um bit para a direita é como dividir por dois** (observe que o bit mais à direita está perdido).

Os **operadores** de deslocamento em Python são um par de **dígrafos**: << e >>, sugerindo claramente em qual direção o deslocamento vai agir.

              `valor << bits                                valor >> bits`
              
               
          
              

      

**O argumento à esquerda desses operadores é um valor inteiro cujos bits são deslocados. O argumento certo determina o tamanho do turno.**

Ela mostra que essa operação certamente não é comutativa.

A prioridade desses operadores é muito alta. Você as verá na tabela atualizada de prioridades, que será exibida no final desta seção.

Dê uma olhada nas mudanças na janela do editor.

Console

A chamada final print() produz a seguinte saída:

              `17 68 8`
          
              

              Output
      

Nota:

-   17 >> 1 → 17 // 2 (**17** piso dividido por **2 à potência de 1**) → 8 (deslocar para a direita por um bit é igual a divisão inteira por dois)
-   17 << 2 → 17 * 4 (**17** multiplicado por **2 à potência de 2**) → 68 (deslocar para a esquerda por dois bits é igual a multiplicação do número inteiro por quatro)

Aqui está a **tabela de prioridades atualizada**, contendo todos os operadores apresentados até agora:
![Pasted image 20230506182701.png](/img/user/0%20-%20VAULT/1%20NOTAS%20LITERAIS/ANELO/Pasted%20image%2020230506182701.png)

---

**3.3.7 RESUMO DA SEÇÃO**

[[0 - VAULT/1 NOTAS LITERAIS/ANELO/ok, agora sim ficou difícil\|ok, agora sim ficou difícil]]

---

1. O Python é compatível com os seguintes operadores lógicos:

-   and → se ambos os operandos forem verdadeiros, a condição é verdadeira, por exemplo, (True and True) é True,
-   or → se qualquer um dos operandos for verdadeiro, a condição é verdadeira, por exemplo, (True or False) é True,
-   not → retorna falso se o resultado for verdadeiro e retorna verdadeiro se o resultado for falso, por exemplo, not True for False.

2. Você pode usar operadores bit a bit para manipular bits únicos de dados. Os seguintes dados de amostra:

-   x = 15, que é 0000 1111 em binário,
-   y = 16, que é 0001 0000 em binário.

será usado para ilustrar o significado dos operadores de bit a bit em Python. Analise os exemplos abaixo:

-   & faz um _bit a_ bit e, por exemplo, x & y = 0 , que é 0000 0000 em binário,
-   | faz um _bit a_ bit ou, por exemplo, x | y = 31, que é 0001 1111 em binário,
-   ˜ faz um _bit a_ bit não, por exemplo, ˜ x = 240 *, que é 1111 0000 em binário,
-   ^ faz um _bit a_ bit xor, por exemplo, x ^ y = 31, que é 0001 1111 em binário,
-   >> faz um _deslocamento à direita_ bit a bit, por exemplo, y >> 1 = 8, que é 0000 1000 em binário,
-   << faz um _turno à esquerda_ bit a bit, por exemplo, y << 3 =, que é 1000 0000 em binário,

* -16 (decimal do complemento de 2 assinado) - leia mais sobre a [operação de complemento](https://en.wikipedia.org/wiki/Two%27s_complement) de Dois.