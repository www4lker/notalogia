---
{"dg-publish":true,"permalink":"/0-vault/1-notas-literais/anelo/latam-2023-3-6-secao-6-operacoes-em-listas/","tags":["ANELO"],"dgHomeLink":true,"dgShowLocalGraph":true,"dgShowFileTree":true,"dgEnableSearch":true}
---

# LATAM 2023 - 3.6 Seção 6 - Operações em listas

## criado em: 
-  09-05-2023 - 15:28

### Conteúdo Relacionado
- notas: 
- tags: #ANELO 
- Fontes & Links: 

---

3.6 Seção 6 - Operações em listas

Nesta seção, você aprenderá como processar listas usando fatias e os operadores _in_ e _not in_. Você também analisará alguns programas simples utilizando o conceito de listas para saber como aplicá-los em projetos mais desafiadores.

3.6.1 A vida interior das listas

Agora, queremos mostrar um recurso importante e muito surpreendente das listas, que as distingue fortemente das variáveis comuns.

Queremos que você o memorize, pois isso pode afetar seus programas futuros e, se esquecido ou esquecido, pode causar problemas graves.

![Pasted image 20230509152958.png](/img/user/0%20-%20VAULT/1%20NOTAS%20LITERAIS/ANELO/Pasted%20image%2020230509152958.png)

O programa:

-   cria uma lista de um elemento chamada list_1;
-   atribui-o a uma nova lista chamada list_2;
-   altera o único elemento de list_1;
-   imprime a lista_2.

A parte surpreendente é o fato de que o programa produzirá: [2], não [1], que parece ser a solução óbvia.

As listas (e muitas outras entidades Python complexas) são armazenadas de maneiras diferentes das variáveis comuns (escalares).

Você poderia dizer que:

-   o nome de uma variável comum é o **nome de seu conteúdo**;
-   o nome de uma lista é o nome de um **local de memória onde a lista é armazenada**.

Leia estas duas linhas mais uma vez: a diferença é essencial para entendermos sobre o que falaremos a seguir.

A atribuição: list_2 = list_1 copia o nome da matriz, não seu conteúdo. Na verdade, os dois nomes (list_1 e list_2) identificam o mesmo local na memória do computador. Modificar um deles afeta o outro e vice-versa.

Como você lida com isso?
*eu vou de chatgpt para aprofundar a explicação* [[0 - VAULT/1 NOTAS LITERAIS/ANELO/lists store references to the underlying object in memory rather than copies of the object itself\|lists store references to the underlying object in memory rather than copies of the object itself]]

3.6.2 [[0 - VAULT/1 NOTAS LITERAIS/ANELO/Os poderes do fatiamento\|Os poderes do fatiamento]]

Felizmente, a solução está ao seu alcance - é chamada de **fatia**.

Uma fatia é um elemento da sintaxe do Python que permite **fazer uma cópia totalmente nova de uma lista ou de partes de uma lista**.

Na verdade, ele copia o conteúdo da lista, não o nome da lista.

Isso é exatamente o que você precisa. Veja o snippet abaixo:

              `list_1 = [1]                                list_2 = list_1[:]                                list_1[0] = 2                                print(list_2)`
              
               
          
              

      

Sua saída é [1].

Esta parte discreta do código descrito como [:] é capaz de produzir uma nova lista.

Uma das formas mais gerais da fatia é a seguinte:

              `my_list[start:end]`
          
              

      

Como você pode ver, ela se assemelha à indexação, mas os dois pontos no interior fazem uma grande diferença.

Uma fatia deste formulário **cria uma nova lista (de destino), recebendo elementos da lista de origem, os elementos dos índices do start ao fin - 1**.

Nota: não para fin, mas para fin - 1. Um elemento com um índice igual ao fin é o primeiro elemento que **não participa da segmentação**.

É possível usar valores negativos para início e fim (assim como na indexação).

Confira o trecho:

              `my_list = [10, 8, 6, 4, 2]                                new_list = my_list[1:3]                                print(new_list)`
              
               
          
              

      

A lista new_list terá elementos end - start (3 - 1 = 2) - aqueles com índices iguais a 1 e 2 (mas não 3).

O resultado do fragmento é: [8, 6]

Execute o código no editor para ver como o Python copia a lista completa e algum fragmento da lista. Sinta-se livre para experimentar!

Console

Incompleta 3.6.3 Fatias - índices negativos

3.6.3 Fatias - índices negativos

Veja o snippet abaixo:

              `my_list[start:end]`

              
               
          
              

      

Para repetir:

-   start é o índice do primeiro elemento **incluído na fatia**;
-   end é o índice do primeiro elemento **não incluído na fatia.**

É assim que **os índices** negativos trabalham com o particionamento:

              `my_list = [10, 8, 6, 4, 2]                                new_list = my_list[1:-1]                                print(new_list)`
              
               
          
              

      

A saída do fragmento é:

              `[8, 6, 4]`
          
              

              Output
      

Se o start especificar um elemento além do descrito no end (do início da lista), a fatia estará **vazia**:

              `my_list = [10, 8, 6, 4, 2]                                new_list = my_list[-1:1]                                print(new_list)`
              
               
          
              

      

A saída do fragmento é:

              `[]`
          
              

              Output
      

Se você omitir o start na fatia, presume-se que você deseja obter uma fatia começando no elemento com índice 0.

Em outras palavras, a fatia deste formulário:

              `my_list[:end]`
              
               
          
              

      

é um equivalente mais compacto de:

              `my_list[0:end]`
              
               
          
              

      

Veja o snippet abaixo:

              `my_list = [10, 8, 6, 4, 2]                                new_list = my_list[:3]                                print(new_list)`
              
               
          
              

      

É por isso que a saída é: [10, 8, 6].

Da mesma forma, se você omitir o end da fatia, pressupõe-se que você deseja que a fatia termine no elemento com o índice len(my_list).

Em outras palavras, a fatia deste formulário:

              `my_list[start:]`
              
               
          
              

      

é um equivalente mais compacto de:

              `my_list[start:len(my_list)]`
              
               
          
              

      

Observe o trecho a seguir:

              `my_list = [10, 8, 6, 4, 2]                                new_list = my_list[3:]                                print(new_list)`
              
               
          
              

      

Sua saída é, portanto: [4, 2].

Como dissemos antes, **a omissão de start e end faz uma cópia de toda a lista**:

              `my_list = [10, 8, 6, 4, 2]                                new_list = my_list[:]                                print(new_list)`
              
               
          
              

      

A saída do snippet é: [10, 8, 6, 4, 2].

# Mais sobre a instrução del

A instrução del descrita anteriormente é capaz de **excluir mais do que apenas os elementos de uma lista de uma só vez - ela também pode excluir fatias**:

              `my_list = [10, 8, 6, 4, 2]                                del my_list[1:3]                                print(my_list)`
              
               
          
              

      

Nota: nesse caso, a fatia **não gera nenhuma nova lista**!

O resultado do snippet é: [10, 4, 2].

Também **é possível excluir todos os elementos** de uma só vez:

              `my_list = [10, 8, 6, 4, 2]                                del my_list[:]                                print(my_list)`
              
               
          
              

      

A lista fica vazia e o resultado é: [].

A remoção da fatia do código muda bastante de significado.

Dê uma olhada:

              `my_list = [10, 8, 6, 4, 2]                                del my_list                                print(my_list)`
              
               
          
              

      

A instrução del **excluirá a lista em si, não seu conteúdo**.

A chamada da função de print() da última linha do código causará um erro de tempo de execução.

Incompleta 3.6.4 Os operadores in e not in

3.6.4 Os operadores in e not in

O Python oferece dois operadores muito eficientes, capazes de **examinar a lista para verificar se um valor específico é armazenado ou não na lista**.

Esses operadores são:

              `elem in my_list                                elem not in my_list`
              
               
          
              

      

O primeiro deles (in) verifica se um determinado elemento (seu argumento à esquerda) está atualmente armazenado em algum lugar dentro da lista (o argumento à direita) - o operador retorna True neste caso.

O segundo (not in) verifica se um determinado elemento (seu argumento à esquerda) está ausente em uma lista - o operador retorna True neste caso.

Veja o código no editor. O trecho mostra os dois operadores em ação. Você consegue adivinhar o resultado? Execute o programa para verificar se você estava certo.

Console

Incompleta 3.6.5 Listas - alguns programas simples

3.6.5 Listas - alguns programas simples

Agora, queremos mostrar alguns programas simples que utilizam listas.

O primeiro deles tenta encontrar o maior valor na lista. Veja o código no editor.

Console

O conceito é bastante simples: assumimos temporariamente que o primeiro elemento é o maior e verificamos a hipótese em relação a todos os elementos restantes na lista.

O código gera 17 (conforme o esperado).

O código pode ser reescrito para utilizar o formulário recém-introduzido do loop for:

              `my_list = [17, 3, 11, 5, 1, 9, 7, 15, 13]                                largest = my_list[0]                                                for i in my_list:                                    if i > largest:                                        largest = i                                                print(largest)`
              
               
          
              

      

O programa acima executa uma comparação desnecessária, quando o primeiro elemento é comparado com ele mesmo, mas isso não é um problema.

O código gera 17 também (nada de incomum).

Se precisar economizar energia do computador, use uma fatia:

              `my_list = [17, 3, 11, 5, 1, 9, 7, 15, 13]                                largest = my_list[0]                                                for i in my_list[1:]:                                    if i > largest:                                        largest = i                                                print(largest)`
              
               
          
              

      

A pergunta é: qual dessas duas ações consome mais recursos de computador - apenas uma comparação ou fatiar quase todos os elementos de uma lista?

Agora vamos encontrar a localização de um determinado elemento dentro de uma lista:

              `my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]                                to_find = 5                                found = False                                                for i in range(len(my_list)):                                    found = my_list[i] == to_find                                    if found:                                        break                                                if found:                                    print("Elemento encontrado no índice", i)                                else:                                    print("ausente")`
              
               
          
              

      

Nota:

-   o valor de destino é armazenado na variável to_find;
-   o status atual da pesquisa é armazenado na variável found (True/False)
-   quando found se torna True, o loop for é encerrado.

Vamos supor que você tenha escolhido os seguintes números na loteria: 3, 7, 11, 42, 34, 49.

Os números que foram desenhados são: 5, 11, 9, 42, 3, 49.

A pergunta é: quantos números você acertou?

Este programa vai lhe dar a resposta:

              `drawn = [5, 11, 9, 42, 3, 49]                                bets = [3, 7, 11, 42, 34, 49]                                v                                                for number in bets:                                    if number in drawn:                                        hits += 1                                                print(hits)`
              
               
          
              

      

Nota:

-   a lista drawn armazena todos os números sorteados;
-   a lista bets armazena suas apostas;
-   a variável hits conta os ocorrências.

A saída do programa é: 4.

  

Incompleta 3.6.6   **LAB**   Operações com listas ‒ básico

---

3.6.6   **LAB**   Operações com listas ‒ básico

---

## Cenário

Imagine uma lista - não muito longa, não muito complicada, apenas uma lista simples que contém alguns números inteiros. Alguns desses números podem ser repetidos, e essa é a pista. Não queremos repetições. Queremos que eles sejam removidos.

Sua tarefa é escrever um programa que remova todas as repetições de números da lista. O objetivo é ter uma lista na qual todos os números não aparecem mais de uma vez.

Nota: suponha que a lista de origem seja codificada dentro do código - você não precisa inseri-la no teclado. Claro, você pode melhorar o código e adicionar uma parte que possa conversar com o usuário e obter todos os dados dele.

Dica: recomendamos que você crie uma nova lista como uma área de trabalho temporária. Você não precisa atualizar a lista in situ.

Não fornecemos dados de teste, pois isso seria muito fácil. Você pode usar o nosso esqueleto.

Console

Concluída

---

**3.6.7 RESUMO DA SEÇÃO**

---

---

**3.6.7 RESUMO DA SEÇÃO**

---

1. Se você tiver uma lista list_1, a seguinte atribuição: list_2 = list_1 não faz uma cópia da lista list_1, mas faz com que as variáveis list_1 e list_2 **apontem para uma mesma lista na memória**. Por exemplo:

              `vehicles_one = ['carro', 'bicicleta', 'motor']                                print(vehicles_one) # outputs: ['carro', 'bicicleta', 'motor']                                                vehicles_two = vehicles_one                                del vehicles_one[0] # exclui 'carro'                                print(vehicles_two) # outputs: ['bicicleta', 'motor']`
              
               
          
              

      

2. Se quiser copiar uma lista ou parte da lista, você pode fazer isso **dividindo**:

              `colors = ['vermelho', 'verde', 'laranja']                                                copy_whole_colors = colors[:]  # copie a lista inteira                                copy_part_colors = colors[0:2]  # copiar parte da lista`
              
               
          
              

      

3. Você também pode usar **índices negativos** para executar fatias. Por exemplo:

              `sample_list = ["A", "B", "C", "D", "E"]                                new_list = sample_list[2:-1]                                print(new_list)  # outputs: ['C', 'D']`
              
               
          
              

      

4. Os start de end e fim **são opcionais** ao executar uma fatia: list[start:end], por exemplo:

              `my_list = [1, 2, 3, 4, 5]                                slice_one = my_list[2: ]                                slice_two = my_list[ :2]                                slice_three = my_list[-2: ]                                                print(slice_one)  # outputs: [3, 4, 5]                                print(slice_two)  # outputs: [1, 2]                                print(slice_three)  # outputs: [4, 5]`
              
               
          
              

      

5. Você pode **excluir fatias** usando a instrução del:

              `my_list = [1, 2, 3, 4, 5]                                del my_list[0:2]                                print(my_list)  # outputs: [3, 4, 5]                                                del my_list[:]                                print(my_list)  # deletes the list content, outputs: []`
              
               
          
              

      

6. Você pode testar se alguns itens **existem em uma lista ou não** estão usando as palavras-chave in e not in, por exemplo:

              `my_list = ["A", "B", 1, 2]                                                print("A" in my_list)  # outputs: True                                print("C" not in my_list)  # outputs: True                                print(2 not in my_list)  # outputs: False`