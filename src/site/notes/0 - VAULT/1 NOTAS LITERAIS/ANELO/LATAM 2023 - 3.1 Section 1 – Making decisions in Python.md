---
{"dg-publish":true,"permalink":"/0-vault/1-notas-literais/anelo/latam-2023-3-1-section-1-making-decisions-in-python/","tags":["python","ANELO",{"1":null},{"2":null},"3:"],"dgHomeLink":true,"dgShowLocalGraph":true,"dgShowFileTree":true,"dgEnableSearch":true,"noteIcon":""}
---

# LATAM 2023 - 3.1 Section 1 – Making decisions in Python

## criado em: 
-  04-05-2023 - 12:38

### Conteúdo Relacionado
- notas: [[0 - VAULT/1 NOTAS LITERAIS/ANELO/LATAM Bem-vindo ao Fundamentos do Python\|LATAM Bem-vindo ao Fundamentos do Python]]
- [[0 - VAULT/1 NOTAS LITERAIS/ANELO/LATAM 2023-11 Seção 1 - Introdução à programação\|LATAM 2023-11 Seção 1 - Introdução à programação]]
- [[0 - VAULT/1 NOTAS LITERAIS/ANELO/LATAM 2023 2 Seção 1 - O Programa Olá, mundo\|LATAM 2023 2 Seção 1 - O Programa Olá, mundo]]
- [[0 - VAULT/1 NOTAS LITERAIS/ANELO/LATAM 2023 2 S 2 - Operadores - ferramentas de manipulação de dados\|LATAM 2023 2 S 2 - Operadores - ferramentas de manipulação de dados]]
- [[0 - VAULT/1 NOTAS LITERAIS/ANELO/LATAM 2023 - 3.5 Section 5 – sorting simple lists\|LATAM 2023 - 3.5 Section 5 – sorting simple lists]]
- tags: #python #ANELO 
- Fontes & Links: 

---
# 3.1 Section 1 – Making decisions in Python


Welcome to Module three! In the first section we will learn about conditional statements and how to use them to make decisions in Python.

## 3.1.1 Questions and answers

A programmer writes a program and the program asks questions.

A computer executes the program and provides the answers. The program must be able to react according to the received answers.

Fortunately, computers know only two kinds of answers:

    yes, this is true;
    no, this is false.

You will never get a response like Let me think...., I don't know, or Probably yes, but I don't know for sure.

To ask questions, Python uses a set of very special operators. Let's go through them one after another, illustrating their effects on some simple examples.
Complete 3.1.2 Comparison: equality operator
## 3.1.2 Comparison: equality operator

Question: are two values equal?

To ask this question, you use the == (equal equal) operator.

Don't forget this important distinction:

    = is an assignment operator, e.g., a = b assigns a with the value of b;
    == is the question are these values equal? so a == b compares a and b.

It is a binary operator with left-sided binding. It needs two arguments and checks if they are equal.

## 3.1.3 Exercises

Now let's ask a few questions. Try to guess the answers.

Question #1: What is the result of the following comparison?

2 == 2

Question #2: What is the result of the following comparison?

2 == 2.

Question #3: What is the result of the following comparison?

1 == 2
Complete 3.1.4 Operators
## 3.1.4 Operators
Equality: the equal to operator (==)

The == (equal to) operator compares the values of two operands. If they are equal, the result of the comparison is True. If they are not equal, the result of the comparison is False.

Look at the equality comparison below – what is the result of this operation?

var == 0
 

Note that we cannot find the answer if we do not know what value is currently stored in the variable var.

If the variable has been changed many times during the execution of your program, or its initial value is entered from the console, the answer to this question can be given only by Python and only at runtime.

Now imagine a programmer who suffers from insomnia, and has to count black and white sheep separately as long as there are exactly twice as many black sheep as white ones.

The question will be as follows:

black_sheep == 2 * white_sheep
 

Due to the low priority of the == operator, the question shall be treated as equivalent to this one:

black_sheep == (2 * white_sheep)
 

So, let's practice your understanding of the == operator now – can you guess the output of the code below?

Console

Run the code and check if you're right.
Inequality: the not equal to operator (!=)

The != (not equal to) operator compares the values of two operands, too. Here is the difference: if they are equal, the result of the comparison is False. If they are not equal, the result of the comparison is True.

Now take a look at the inequality comparison below – can you guess the result of this operation?

var = 0  # Assigning 0 to var
print(var != 0)
 
var = 1  # Assigning 1 to var
print(var != 0)
 

Run the code and check if you're right.
Comparison operators: greater than

You can also ask a comparison question using the > (greater than) operator.

If you want to know if there are more black sheep than white ones, you can write it as follows:

black_sheep > white_sheep  # Greater than
 

True confirms it; False denies it.
Comparison operators: greater than or equal to

The greater than operator has another special, non-strict variant, but it's denoted differently than in classical arithmetic notation: >= (greater than or equal to).

There are two subsequent signs, not one.

Both of these operators (strict and non-strict), as well as the two others discussed in the next section, are binary operators with left-sided binding, and their priority is greater than that shown by == and !=.

If we want to find out whether or not we have to wear a warm hat, we ask the following question:

centigrade_outside >= 0.0  # Greater than or equal to
 

Comparison operators: less than/less than or equal to

As you've probably already guessed, the operators used in this case are: the < (less than) operator and its non-strict sibling: <= (less than or equal to).

Look at this simple example:

current_velocity_mph < 85  # Less than
current_velocity_mph <= 85  # Less than or equal to
 

We're going to check if there's a risk of being fined by the highway police (the first question is strict, the second isn't).
Incomplete 3.1.5 Making use of the answers
## 3.1.5 Making use of the answers

What can you do with the answer (i.e., the result of a comparison operation) you get from the computer?

There are at least two possibilities: first, you can memorize it (store it in a variable) and make use of it later. How do you do that? Well, you use an arbitrary variable like this:

answer = number_of_lions >= number_of_lionesses
 

The content of the variable will tell you the answer to the question asked.

**The second possibility is more convenient and far more common: you can use the answer you get to make a decision about the future of the program.**

You need a special instruction for this purpose, and we'll discuss it very soon.

Now we need to update our priority table, and put all the new operators into it. It now looks as follows:
![Pasted image 20230504140156.png](/img/user/0%20-%20VAULT/1%20NOTAS%20LITERAIS/ANELO/Pasted%20image%2020230504140156.png)
[[0 - VAULT/1 NOTAS LITERAIS/ANELO/lista de operadores aritmeticos e suas prioridades\|lista de operadores aritmeticos e suas prioridades]]

## 3.1.6   LAB   Variables ‒ Questions and answers
Scenario

Using one of the comparison operators in Python, write a simple two-line program that takes the parameter n as input, which is an integer, and prints False if n is less than 100, and True if n is greater than or equal to 100.

Don't create any if blocks (we're going to talk about them very soon). Test your code using the data we've provided for you.

Complete 3.1.7 Conditions and conditional execution
3.1.7 Conditions and conditional execution

You already know how to ask Python questions, but you still don't know how to make reasonable use of the answers. You have to have a mechanism which will allow you to do something if a condition is met, and not do it if it isn't.

It's just like in real life: you do certain things or you don't when a specific condition is met or not, e.g., you go for a walk if the weather is good, or stay home if it's wet and cold.

To make such decisions, Python offers a special instruction. Due to its nature and its application, it's called a conditional instruction (or conditional statement).

There are several variants of it. We'll start with the simplest, increasing the difficulty slowly.

The first form of a conditional statement, which you can see below is written very informally but figuratively:

if true_or_not:
    do_this_if_true
 

This conditional statement consists of the following, strictly necessary, elements in this and this order only:

    the if keyword;
    one or more white spaces;
    an expression (a question or an answer) whose value will be interpreted solely in terms of True (when its value is non-zero) and False (when it is equal to zero);
    a colon followed by a newline;
    an indented instruction or set of instructions (at least one instruction is absolutely required); the indentation may be achieved in two ways – by inserting a particular number of spaces (the recommendation is to use four spaces of indentation), or by using the tab character; note: if there is more than one instruction in the indented part, the indentation should be the same in all lines; even though it may look the same if you use tabs mixed with spaces, it's important to make all indentations exactly the same – Python 3 does not allow the mixing of spaces and tabs for indentation.

How does that statement work?

    If the true_or_not expression represents the truth (i.e., its value is not equal to zero), the indented statement(s) will be executed;
    if the true_or_not expression does not represent the truth (i.e., its value is equal to zero), the indented statement(s) will be omitted (ignored), and the next executed instruction will be the one after the original indentation level.


In real life, we often express a desire:

if the weather is good, we'll go for a walk

then, we'll have lunch

As you can see, having lunch is not a conditional activity and doesn't depend on the weather.

Knowing what conditions influence our behavior, and assuming that we have the parameterless functions go_for_a_walk() and have_lunch(), we can write the following snippet:

if the_weather_is_good:
    go_for_a_walk()
have_lunch()
 

Conditional execution: the if statement

If a certain sleepless Python developer falls asleep when he or she counts 120 sheep, and the sleep-inducing procedure may be implemented as a special function named sleep_and_dream(), the whole code takes the following shape:

if sheep_counter >= 120: # Evaluate a test expression
    sleep_and_dream() # Execute if test expression is True
 

You can read it as: if sheep_counter is greater than or equal to 120, then fall asleep and dream (i.e., execute the sleep_and_dream function.)

We've said that conditionally executed statements have to be indented. This creates a very legible structure, clearly demonstrating all possible execution paths in the code.

Take a look at the following code:

if sheep_counter >= 120:
    make_a_bed()
    take_a_shower()
    sleep_and_dream()
feed_the_sheepdogs()
 

As you can see, making a bed, taking a shower and falling asleep and dreaming are all executed conditionally – when sheep_counter reaches the desired limit.

Feeding the sheepdogs, however, is always done (i.e., the feed_the_sheepdogs() function is not indented and does not belong to the if block, which means it is always executed.)

Now we're going to discuss another variant of the conditional statement, which also allows you to perform an additional action when the condition is not met.
Conditional execution: the if-else statement

We started out with a simple phrase which read: If the weather is good, we will go for a walk.

Note: there is not a word about what will happen if the weather is bad. We only know that we won't go outdoors, but what we could do instead is not known. We may want to plan something in case of bad weather, too.

We can say, for example: If the weather is good, we will go for a walk, otherwise we will go to a theater.

Now we know what we'll do if the conditions are met, and we know what we'll do if not everything goes our way. In other words, we have a "Plan B".

Python allows us to express such alternative plans. This is done with a second, slightly more complex form of the conditional statement, the if-else statement:

if true_or_false_condition:
    perform_if_condition_true
else:
    perform_if_condition_false
 

Thus, there is a new word: else – this is a keyword.

The part of the code which begins with else says what to do if the condition specified for the if is not met (note the colon after the word).

The if-else execution goes as follows:

    if the condition evaluates to True (its value is not equal to zero), the perform_if_condition_true statement is executed, and the conditional statement comes to an end;
    if the condition evaluates to False (it is equal to zero), the perform_if_condition_false statement is executed, and the conditional statement comes to an end.

The if-else statement: more conditional execution

By using this form of conditional statement, we can describe our plans as follows:

if the_weather_is_good:
    go_for_a_walk()
else:
    go_to_a_theater()
have_lunch()
 

If the weather is good, we'll go for a walk. Otherwise, we'll go to a theater. No matter if the weather is good or bad, we'll have lunch afterwards (after the walk or after going to the theater).

Everything we've said about indentation works in the same manner inside the else branch:

if the_weather_is_good:
    go_for_a_walk()
    have_fun()
else:
    go_to_a_theater()
    enjoy_the_movie()
have_lunch()
 

Nested if-else statements

Now let's discuss two special cases of the conditional statement.

First, consider the case where the instruction placed after the if is another if.

Read what we have planned for this Sunday. If the weather is fine, we'll go for a walk. If we find a nice restaurant, we'll have lunch there. Otherwise, we'll eat a sandwich. If the weather is poor, we'll go to the theater. If there are no tickets, we'll go shopping in the nearest mall.

Let's write the same in Python. Consider carefully the code here:

if the_weather_is_good:
    if nice_restaurant_is_found:
        have_lunch()
    else:
        eat_a_sandwich()
else:
    if tickets_are_available:
        go_to_the_theater()
    else:
        go_shopping()

Here are two important points:

    this use of the if statement is known as nesting; remember that every else refers to the if which lies at the same indentation level; you need to know this to determine how the ifs and elses pair up;
    consider how the indentation improves readability, and makes the code easier to understand and trace.

The elif statement

The second special case introduces another new Python keyword: elif. As you probably suspect, it's a shorter form of else if.

elif is used to check more than just one condition, and to stop when the first statement which is true is found.

Our next example resembles nesting, but the similarities are very slight. Again, we'll change our plans and express them as follows: If the weather is fine, we'll go for a walk, otherwise if we get tickets, we'll go to the theater, otherwise if there are free tables at the restaurant, we'll go for lunch; if all else fails, we'll stay home and play chess.

Have you noticed how many times we've used the word otherwise? This is the stage where the elif keyword plays its role.

Let's write the same scenario using Python:

if the_weather_is_good:
    go_for_a_walk()
elif tickets_are_available:
    go_to_the_theater()
elif table_is_available:
    go_for_lunch()
else:
    play_chess_at_home()
 

The way to assemble subsequent if-elif-else statements is sometimes called a cascade.

Notice again how the indentation improves the readability of the code.

Some additional attention has to be paid in this case:

    you mustn't use else without a preceding if;
    else is always the last branch of the cascade, regardless of whether you've used elif or not;
    else is an optional part of the cascade, and may be omitted;
    if there is an else branch in the cascade, only one of all the branches is executed;
    if there is no else branch, it's possible that none of the available branches is executed.

This may sound a little puzzling, but hopefully some simple examples will help shed more light.
Incomplete 3.1.8 Analyzing code samples
3.1.8 Analyzing code samples

Now we're going to show you some simple yet complete programs. We won't explain them in detail, because we consider the comments (and the variable names) inside the code to be sufficient guides.

All the programs solve the same problem – they find the largest of several numbers and print it out.

Example 1:

We'll start with the simplest case – how to identify the larger of two numbers:

# Read two numbers
number1 = int(input("Enter the first number: "))
number2 = int(input("Enter the second number: "))
 
# Choose the larger number
if number1 > number2:
    larger_number = number1
else:
    larger_number = number2
 
# Print the result
print("The larger number is:", larger_number)
 

The above snippet should be clear – it reads two integer values, compares them, and finds which is the larger.

Example 2:

Now we're going to show you one intriguing fact. Python has an interesting feature – look at the code below:

# Read two numbers
number1 = int(input("Enter the first number: "))
number2 = int(input("Enter the second number: "))
 
# Choose the larger number
if number1 > number2: larger_number = number1
else: larger_number = number2
 
# Print the result
print("The larger number is:", larger_number)
 

Note: if any of the if-elif-else branches contains just one instruction, you may code it in a more comprehensive form (you don't need to make an indented line after the keyword, but just continue the line after the colon).

This style, however, may be misleading, and we're not going to use it in our future programs, but it's definitely worth knowing if you want to read and understand someone else's programs.

There are no other differences in the code.

Example 3:

It's time to complicate the code – let's find the largest of three numbers. Will it enlarge the code? A bit.

We assume that the first value is the largest. Then we verify this hypothesis with the two remaining values.

Look at the code below:

# Read three numbers
number1 = int(input("Enter the first number: "))
number2 = int(input("Enter the second number: "))
number3 = int(input("Enter the third number: "))
 
# We temporarily assume that the first number
# is the largest one.
# We will verify this soon.
largest_number = number1
 
# We check if the second number is larger than the current largest_number
# and update the largest_number if needed.
if number2 > largest_number:
    largest_number = number2
 
# We check if the third number is larger than the current largest_number
# and update the largest_number if needed.
if number3 > largest_number:
    largest_number = number3
 
# Print the result
print("The largest number is:", largest_number)
 

This method is significantly simpler than trying to find the largest number all at once, by comparing all possible pairs of numbers (i.e., first with second, second with third, third with first). Try to rebuild the code for yourself.

Console
Incomplete 3.1.9 Pseudocode and introduction to loops
3.1.9 Pseudocode and introduction to loops

You should now be able to write a program which finds the largest of four, five, six, or even ten numbers.

You already know the scheme, so extending the size of the problem will not be particularly complex.

But what happens if we ask you to write a program that finds the largest of two hundred numbers? Can you imagine the code?

You'll need two hundred variables. If two hundred variables isn't bad enough, try to imagine searching for the largest of a million numbers.

Imagine a code that contains 199 conditional statements and two hundred invocations of the input() function. Luckily, you don't need to deal with that. There's a simpler approach.

We'll ignore the requirements of Python syntax for now, and try to analyze the problem without thinking about the real programming. In other words, we'll try to write the algorithm, and when we're happy with it, we'll implement it.

In this case, we'll use a kind of notation which is not an actual programming language (it can be neither compiled nor executed), but it is formalized, concise and readable. It's called pseudocode.

Let's look at our pseudocode below:

largest_number = -999999999
number = int(input())
if number == -1:
    print(largest_number)
    exit()
if number > largest_number:
    largest_number = number
# Go to line 02
 


What's happening in it?

Firstly, we can simplify the program if, at the very beginning of the code, we assign the variable largest_number with a value which will be smaller than any of the entered numbers. We'll use -999999999 for that purpose.

Secondly, we assume that our algorithm will not know in advance how many numbers will be delivered to the program. We expect that the user will enter as many numbers as she/he wants – the algorithm will work well with one hundred and with one thousand numbers. How do we do that?

We make a deal with the user: when the value -1 is entered, it will be a sign that there are no more data and the program should end its work.

Otherwise, if the entered value is not equal to -1, the program will read another number, and so on.

The trick is based on the assumption that any part of the code can be performed more than once – precisely, as many times as needed.

Performing a certain part of the code more than once is called a loop. The meaning of this term is probably obvious to you.

Lines 02 through 08 make a loop. We'll pass through them as many times as needed to review all the entered values.

Can you use a similar structure in a program written in Python? Yes, you can.

  Extra Info  

Python often comes with a lot of built-in functions that will do the work for you. For example, to find the largest number of all, you can use a Python built-in function called max(). You can use it with multiple arguments. Analyze the code below:

# Read three numbers.
number1 = int(input("Enter the first number: "))
number2 = int(input("Enter the second number: "))
number3 = int(input("Enter the third number: "))
 
# Check which one of the numbers is the greatest
# and pass it to the largest_number variable.
 
largest_number = max(number1, number2, number3)
 
# Print the result.
print("The largest number is:", largest_number)
 


By the same fashion, you can use the min() function to return the lowest number. You can rebuild the above code and experiment with it in the Sandbox.

We're going to talk about these (and many other) functions soon. For the time being, our focus will be on conditional execution and loops to let you gain more confidence in programming and teach you the skills that will let you fully understand and apply the two concepts in your code. So, for now, we're not taking any shortcuts.

Complete 3.1.10   LAB   Comparison operators and conditional execution
3.1.10   LAB   Comparison operators and conditional execution
Scenario

Spathiphyllum, more commonly known as a peace lily or white sail plant, is one of the most popular indoor houseplants that filters out harmful toxins from the air. Some of the toxins that it neutralizes include benzene, formaldehyde, and ammonia.

Imagine that your computer program loves these plants. Whenever it receives an input in the form of the word Spathiphyllum, it involuntarily shouts to the console the following string: "Spathiphyllum is the best plant ever!"

Write a program that utilizes the concept of conditional execution, takes a string as input, and:

    prints the sentence "Yes - Spathiphyllum is the best 
    plant ever!" to the screen if the inputted string is "Spathiphyllum" (upper-case)
    prints "No, I want a big Spathiphyllum!" if the inputted string is "spathiphyllum" (lower-case)
    prints "Spathiphyllum! Not [input]!" otherwise. Note: [input] is the string taken as input.

Test your code using the data we've provided for you. And get yourself a Spathiphyllum, too!

Test Data:

Sample input:

spathiphyllum

Expected output:

No, I want a big Spathiphyllum!
Output

Sample input:

pelargonium

Expected output:

Spathiphyllum! Not pelargonium!
Output

Sample input:

Spathiphyllum

Expected output:

Yes - Spathiphyllum is the best plant ever!
Output

Console

Incomplete 3.1.11   LAB   Essentials of the if-else statement
3.1.11   LAB   Essentials of the if-else statement
Scenario

Once upon a time there was a land – a land of milk and honey, inhabited by happy and prosperous people. The people paid taxes, of course – their happiness had limits. The most important tax, called the Personal Income Tax (PIT for short) had to be paid once a year, and was evaluated using the following rule:

    if the citizen's income was not higher than 85,528 thalers, the tax was equal to 18% of the income minus 556 thalers and 2 cents (this was what they called tax relief)
    if the income was higher than this amount, the tax was equal to 14,839 thalers and 2 cents, plus 32% of the surplus over 85,528 thalers.

Your task is to write a tax calculator.

    It should accept one floating-point value: the income.
    Next, it should print the calculated tax, rounded to full thalers. There's a function named round() which will do the rounding for you – you'll find it in the skeleton code in the editor.

Note: this happy country never returned any money to its citizens. If the calculated tax was less than zero, it would only mean no tax at all (the tax was equal to zero). Take this into consideration during your calculations.

Look at the code in the editor – it only reads one input value and outputs a result, so you need to complete it with some smart calculations.

Test your code using the data we've provided.

Test Data

Sample input:

10000

Expected output:

The tax is: 1244.0 thalers
Output

Sample input:

100000

Expected output:

The tax is: 19470.0 thalers
Output

Sample input:

1000

Expected output:

The tax is: 0.0 thalers
Output

Sample input:

-100

Expected output:

The tax is: 0.0 thalers
Output

Console

Incomplete 3.1.12   LAB   Essentials of the if-elif-else statement
3.1.12   LAB   Essentials of the if-elif-else statement
Scenario

As you surely know, due to some astronomical reasons, years may be leap or common. The former are 366 days long, while the latter are 365 days long.

Since the introduction of the Gregorian calendar (in 1582), the following rule is used to determine the kind of year:

    if the year number isn't divisible by four, it's a common year;
    otherwise, if the year number isn't divisible by 100, it's a leap year;
    otherwise, if the year number isn't divisible by 400, it's a common year;
    otherwise, it's a leap year.

Look at the code in the editor – it only reads a year number, and needs to be completed with the instructions implementing the test we've just described.

The code should output one of two possible messages, which are Leap year or Common year, depending on the value entered.

It would be good to verify if the entered year falls into the Gregorian era, and output a warning otherwise: Not within the Gregorian calendar period. Tip: use the != and % operators.

Test your code using the data we've provided.

Test Data:

Sample input:

2000

Expected output:

Leap year
Output

Sample input:

2015

Expected output:

Common year
Output

Sample input:

1999

Expected output:

Common year
Output

Sample input:

1996

Expected output:

Leap year
Output

Sample input:

1580

Expected output:

Not within the Gregorian calendar period
Output

Console

Complete
3.1.13 SECTION SUMMARY
3.1.13 SECTION SUMMARY

1. The comparison (otherwise known as relational) operators are used to compare values. The table below illustrates how the comparison operators work, assuming that x = 0, y = 1, and z = 0:
Operator 	Description 	Example
== 	returns True if operands' values are equal, and False otherwise 	
x == y  # False
x == z  # True
!= 	returns True if operands' values are not equal, and False otherwise 	
x != y  # True
x != z  # False
> 	True if the left operand's value is greater than the right operand's value, and False otherwise 	
x > y  # False
y > z  # True
< 	True if the left operand's value is less than the right operand's value, and False otherwise 	
x < y  # True
y < z  # False
>= 	True if the left operand's value is greater than or equal to the right operand's value, and False otherwise 	
x >= y  # False
x >= z  # True
y >= z  # True
<= 	True if the left operand's value is less than or equal to the right operand's value, and False otherwise 	
x <= y  # True
x <= z  # True
y <= z  # False

2. When you want to execute some code only if a certain condition is met, you can use a conditional statement:

    a single if statement, e.g.:

x = 10
 
if x == 10: # condition
    print("x is equal to 10")  # Executed if the condition is True.
 

    a series of if statements, e.g.:

x = 10
 
if x > 5: # condition one
    print("x is greater than 5")  # Executed if condition one is True.
 
if x < 10: # condition two
    print("x is less than 10")  # Executed if condition two is True.
 
if x == 10: # condition three
    print("x is equal to 10")  # Executed if condition three is True.
 

    Each if statement is tested separately.

    an if-else statement, e.g.:

x = 10
 
if x < 10: # condition
    print("x is less than 10")  # Executed if the condition is True.
 
else:
    print("x is greater than or equal to 10")  # Executed if the condition is False.
 

    a series of if statements followed by an else, e.g.:

x = 10
 
if x > 5: # condition one
    print("x is greater than 5")  # Executed if condition one is True.
 
if x < 10: # condition two
    print("x is less than 10")  # Executed if condition two is True.
 
if x == 10: # condition three
     print("x is equal to 10")  # Executed if condition three is True.
 

    Each if is tested separately. The body of else is executed if the last if is False.

    The if-elif-else statement, e.g.:

x = 10
 
if x == 10: # True
    print("x == 10")
 
if x > 15: # False
    print("x > 15")
 
elif x > 10: # False
    print("x > 10")
 
elif x > 5: # True
    print("x > 5")
 
else:
    print("else will not be executed")
 

    If the condition for if is False, the program checks the conditions of the subsequent elif blocks - the first elif block that is True is executed. If all the conditions are False, the else block will be executed.

    Nested conditional statements, e.g.:

x = 10
 
if x > 5: # True
    if x == 6: # False
        print("nested: x == 6")
    elif x == 10: # True
        print("nested: x == 10")
    else:
        print("nested: else")
else:
    print("else")
 

# 3.2 Section 2 – Loops in Python
![Pasted image 20230504155034.png](/img/user/0%20-%20VAULT/1%20NOTAS%20LITERAIS/ANELO/Pasted%20image%2020230504155034.png)


Na segunda seção, você aprenderá sobre loops em Python e, especificamente, os loops _while_ e _for_. Você aprenderá como criar (e evitar cair) infinitos loops, como sair de loops e pular iterações de loop específicas. Vamos lá?

## 3.2.1 Fazendo um loop no seu código com while

Você concorda com a afirmação apresentada abaixo?

              `enquanto há algo para fazer                                    faça isso`
              
               
          
              

      

Observe que esse registro também declara que, se não houver nada a fazer, nada acontecerá.

Em geral, em Python, um loop pode ser representado da seguinte forma:

              `while                                    instruction`
              
               
          
              

      

Se você observar algumas semelhanças com a instrução _if_, tudo bem. Na verdade, a diferença sintática é apenas uma: você usa a palavra while em vez da palavra if.

A diferença semática é mais importante: quando a condição é atendida, _se_ executa suas instruções **apenas uma** vez; _Enquanto_ **repete a execução, enquanto a condição avalia como True**.

Nota: todas as regras relacionadas à **indentação** também são aplicáveis aqui. Mostraremos isso em breve.

Veja o algoritmo abaixo:

              `while conditional_expression:                                    instruction_one                                    instruction_two                                    instruction_three                                    :                                    :                                    instruction_n`
              
               
          
              

      

Agora é importante lembrar que:

-   se você quiser executar **mais de uma instrução dentro de um loop** while, você deve (como no if) **recuar** todas as instruções da mesma maneira;
-   uma instrução ou um conjunto de instruções executadas dentro do loop while é chamado de **corpo do loop**;
-   se a condição for False (igual a zero) quando for testada pela primeira vez, o corpo não será executado uma única vez (observe a analogia de não ter que fazer nada se não houver nada a fazer);
-   o corpo deve ser capaz de alterar o valor da condição, porque se a condição for True no início, o corpo poderá ser executado continuamente até o infinito (observe que fazer algo geralmente diminui o número de coisas a fazer).

3.2.2 Um loop infinito

Um loop infinito, também chamado de **loop** infinito, é uma sequência de instruções em um programa que se repete indefinidamente (loop infinitamente).

Aqui está um exemplo de um loop que não é capaz de concluir sua execução:

              `while True:                                    print("Estou preso dentro de um loop.")`
              
               
          
              

      

Esse loop exibirá infinitamente "Estou preso dentro de um loop". na tela.

  **Nota**  

Se você quiser obter a melhor experiência de aprendizagem ao ver como um loop infinito se comporta, inicie o IDLE, crie um novo arquivo, copie e cole o código acima, salve o arquivo e execute o programa. O que você verá é a sequência interminável de "Estou preso dentro de um loop". strings impressas na janela do console do Python. Para encerrar o programa, basta pressionar _Ctrl-C_ (ou _Ctrl-Break_ em alguns computadores). Isso fará com que uma exceção KeyboardInterrupt e deixe seu programa sair do loop. Falaremos sobre isso mais adiante neste curso.

Vamos voltar para o desenho do algoritmo que mostramos recentemente. Vamos mostrar como usar esse loop recém-aprendido para encontrar o maior número de um grande conjunto de dados inseridos.

Analise o programa com cuidado. Veja onde o loop começa (linha 8). Localize o corpo do loop e descubra **como o corpo sai** :

              `# Armazene o maior número atual aqui.                                largest_number = -999999999                                                # Insira o primeiro valor.                                number = int(input("Digite um número ou digite -1 para parar: "))                                                # Se o número não for igual a -1, continue.                                while number != -1:                                    # O número é maior que o maior_número?                                    if number > largest_number:                                        # Sim, atualize o maior_número.                                        largest_number = number                                    # Insira o próximo número.                                    number = int(input("Digite um número ou digite -1 para parar: "))                                                # Imprima o maior número.                                print("O maior número é:", largest_number)`
              
               
          
              

      

Veja como esse código implementa o algoritmo que mostramos anteriormente.

Concluída 3.2.3 O loop while: mais exemplos

### 3.2.3 O loop while: mais exemplos
[[ loop while exemplo dissecado\| loop while exemplo dissecado]]

Vejamos outro exemplo empregando o loop while. Siga os comentários para descobrir a ideia e a solução.

              `# Um programa que lê uma sequência de números                                # e conta quantos números são pares e quantos são ímpares.                                # O programa termina quando zero é digitado.                                                odd_numbers = 0                                even_numbers = 0                                                # Leia o primeiro número.                                number = int(input("Digite um número ou digite 0 para parar: "))                                                # 0 termina a execução.                                while number != 0:                                    # Verifique se o número é ímpar.                                    if number % 2 == 1:                                        # Aumente o contador odd_numbers.                                        odd_numbers += 1                                    else:                                        # Aumente o contador even_numbers.                                        even_numbers += 1                                    # Leia o número seguinte.                                    number = int(input("Digite um número ou digite 0 para parar: "))                                                # Imprimir resultados.                                print("Números ímpares contam:", odd_numbers)                                print("Números pares contam:", even_numbers)`
              
               
          
              

      

Determinadas expressões podem ser simplificadas sem alterar o comportamento do programa.

Tente se lembrar de como o Python interpreta a verdade de uma condição e observe que essas duas formas são equivalentes:

while number != 0: e while number:.

A condição que verifica se um número é ímpar também pode ser codificada nessas formas equivalentes:

if number % 2 == 1: e if number % 2:.

## Usando uma variável counter para sair do loop

Veja o snippet abaixo:

              `counter = 5                                while counter != 0:                                    print("Dentro do laço.", counter)                                    counter -= 1                                print("Fora do circuito.", counter)`
              
               
          
              

      

Este código destina-se a imprimir a cadeia de caracteres "dentro do loop". e o valor armazenado na variável do counter durante um determinado loop exatamente cinco vezes. Quando a condição não for atendida (a variável do counter atingiu 0), o loop é encerrado e a mensagem "Fora do loop" . assim como o valor armazenado no counter é impresso.

Mas há uma coisa que pode ser escrita de forma mais compacta: a condição do loop while.

Você consegue ver a diferença?

              `counter = 5                                while counter:                                    print("Dentro do laço.", counter)                                    counter -= 1                                print("Fora do circuito.", counter)`
              
               
          
              

      

É mais compacto do que anteriormente? Um pouco. É mais legível? Isso é discutível.

  **Lembre-se**  

Não se sinta obrigado a codificar seus programas de uma maneira que seja sempre a mais curta e a mais compacta. A legibilidade pode ser um fator mais importante. Mantenha seu código pronto para um novo programador.

  

Incompleta 3.2.4   **LAB**   Adivinhe o número secreto

---

3.2.4   **LAB**   Adivinhe o número secreto

---

## Cenário

Um jovem mágico escolheu um número secreto. Ele o ocultou em uma variável chamada secret_number. Ele quer que todos que executam seu programa joguem o jogo _Adivinhe o número secreto_ e adivinhem qual número ele escolheu para eles. Quem não adivinhar o número ficará para sempre em um loop infinito! Infelizmente, ele não sabe como completar o código.

Sua tarefa é ajudar o mágico a preencher o código no editor de forma que o código:

-   solicitará que o usuário insira um número inteiro;
-   vai usar um while loop;
-   verificará se o número inserido pelo usuário é igual ao número escolhido pelo mágico. Se o número escolhido pelo usuário for diferente do número secreto do mago, o usuário deverá ver a mensagem "Ha ha! Você está preso no meu loop!" E será solicitado a inserir um número novamente. Se o número inserido pelo usuário corresponder ao número escolhido pelo mago, ele deverá ser impresso na tela, e o mago deve dizer as seguintes palavras: "Muito bem, trouxa! Você está livre agora."

O mágico está contando com você! Não o desaponte.

**INFORMAÇÕES EXTRA**

A propósito, observe a função print(). A maneira como usamos aqui é chamada _de impressão de várias linhas_. Você pode usar aspas **triplas para** imprimir sequências de caracteres em várias linhas para facilitar a leitura ou criar um design especial baseado em texto. Experimente.

Console

Concluída 3.2.5 Fazendo um loop no seu código com for

3.2.5 Fazendo um loop no seu código com for

Outro tipo de loop disponível no Python vem da observação de que, às vezes, é mais importante **contar as "voltas" do loop** do que verificar as condições.

Imagine que o corpo de um loop precisa ser executado exatamente uma centena de vezes. Se você quiser usar o loop while, pode ser assim:

              `i = 0                                while i < 100:                                    # do_something()                                    i += 1`
              
               
          
              

      

Seria bom se alguém pudesse fazer essa contagem chata para você. Isso é possível?

Claro que sim - há um loop especial para esses tipos de tarefas, e o nome dele é for

Na verdade, o for loop for foi projetado para realizar tarefas mais complicadas - **ele pode "navegar" em grandes coleções de itens de dados por item**. Mostraremos como fazer isso em breve, mas agora vamos apresentar uma variante mais simples de sua aplicação.

Confira o trecho:

              `for i in range(100):                                    # do_something()                                    pass`
              
               
          
              

      

Existem alguns elementos novos. Vamos falar sobre eles:

-   a _palavra_-chave for abre o loop for; observação - não há nenhuma condição depois; você não precisa pensar nas condições, pois elas são verificadas internamente, sem qualquer intervenção;
-   qualquer variável após a _palavra_ -chave for **é a variável** de controle do loop; conta as voltas do loop e o faz automaticamente;
-   a _palavra_-chave in introduz um elemento de sintaxe que descreve o intervalo de valores possíveis que estão sendo atribuídos à variável de controle;
-   a função range() (essa é uma função muito especial) é responsável por gerar todos os valores desejados da variável de controle; em nosso exemplo, a função criará (podemos até dizer que alimentará **o** loop com) valores subsequentes do seguinte conjunto: 0, 1, 2 .. 97, 98, 99; note Nota: nesse caso, a função range() inicia seu trabalho de 0 e o conclui uma etapa (um número inteiro) antes do valor do argumento; ----- mais sobre a função Range em [[0 - VAULT/1 NOTAS LITERAIS/ANELO/3 Esses em range\|3 Esses em range]]
-   observe a _palavra-chave pass_ dentro do corpo do loop - ela não faz nada; é **uma instrução** vazia - nós a colocamos aqui porque a sintaxe do loop for exige pelo menos uma instrução dentro do corpo (a propósito - if, elif, else e while expressamos a mesma coisa)

Nossos próximos exemplos serão um pouco mais modestos no número de repetições de loop.

Dê uma olhada no snippet abaixo. Você consegue prever a saída?

Console

Execute o código para verificar se você estava certo.

Nota:

-   o loop foi executado dez vezes (é o argumento da função range())
-   o valor da última variável de controle é 9 (não 10, **pois começa em 0**, não em 1)

A invocação da função range() pode ser equipada com dois argumentos, não apenas um:

              `for i in range(2, 8):                                    print("O valor de i é atualmente", i)`
              
               
          
              

      

Nesse caso, o primeiro argumento determina o (primeiro) valor inicial da variável de controle.

O último argumento mostra o primeiro valor em que a variável de controle não será atribuída.

Nota: a função range() **aceita apenas números inteiros como argumentos** e gera sequências de números inteiros.

Você consegue adivinhar o resultado do programa? Execute-o para verificar se você também estava nesse momento.

O primeiro valor mostrado é 2 (extraído do primeiro argumento do range().)

O último é 7 (embora o segundo argumento do range() seja 8).

Concluída 3.2.6 Mais sobre o loop for e a funçao range() com três argumentos

3.2.6 Mais sobre o loop for e a funçao range() com três argumentos

A função range() também pode aceitar **três argumentos** - dê uma olhada no código no editor.

Console

O terceiro argumento é um **incremento** - é um valor adicionado para controlar a variável a cada volta do loop (como você pode suspeitar, o **valor padrão do incremento é 1**).

Você pode nos dizer quantas linhas aparecerão no console e quais valores elas conterão?

Execute o programa para descobrir se você está certo.

Você poderá ver as seguintes linhas na janela do console:

              `O valor de i é atualmente 2                                O valor de i é atualmente 5`
          
              

              Output
      

Você sabe por quê? O primeiro argumento passado para a função range() nos diz qual é o número **inicial** da sequência (portanto, 2 na saída). O segundo argumento diz à função onde **parar** a sequência (a função gera números até o número indicado pelo segundo argumento, mas não o inclui). Por fim, o terceiro argumento indica a **etapa**, que realmente significa a diferença entre cada número na sequência de números gerada pela função.

2 (número inicial) → 5 (incremento de 2 por 3 é igual a 5 - o número está dentro do intervalo de 2 a 8) → 8 (incremento de 5 por 3 é igual a 8 - o número não está dentro do intervalo de 2 a 8, porque o O parâmetro stop não é incluído na sequência de números gerada pela função.)

Nota: se o conjunto gerado pela função range() estiver vazio, o loop não executará seu corpo.

Assim como aqui - não haverá saída:

              `for i in range(1, 1):                                    print("O valor de i é atualmente", i)`
              
               
          
              

      

Observação: o conjunto gerado pelo range() deve ser classificado em **ordem crescente**. Não há como forçar o range() a criar um conjunto de uma forma diferente quando a função range() aceitar exatamente dois argumentos. Isso significa que o segundo argumento do range() deve ser maior que o primeiro.

Assim, não haverá saída aqui:

              `for i in range(2, 1):                                    print("O valor de i é atualmente", i)`
              
               
          
              

      

Vamos dar uma olhada em um programa curto, cuja tarefa é escrever alguns dos primeiros poderes de dois:

Console

A variável expo é usada como uma variável de controle para o loop e indica o valor atual do _expoente_. A exponenciação em si é substituída pela multiplicação por dois. Como 2 0 é igual a 1, 2 × 1 é igual a 2 1, 2 × 2 1 é igual a 2 2 e assim por diante. Qual é o maior expoente para o qual nosso programa ainda imprime o resultado?

Execute o código e verifique se a saída corresponde às suas expectativas.

  

Concluída 3.2.7   **LAB**   Essenciais do loop _for_ – contando mississippy

---

3.2.7   **LAB**   Essenciais do loop _for_ – contando mississippy

---

## Cenário

Você sabe o que é o Mississipi? Bem, é o nome de um dos estados e riachos dos Estados Unidos. O Rio Mississipi tem cerca de 2.340 milhas de comprimento, o que o torna o segundo maior rio dos Estados Unidos (o mais longo é o Rio Missouri). É tão longo que uma única gota de água precisa de 90 dias para percorrer todo o seu comprimento!

A palavra _Mississipi_ também é usada para uma finalidade ligeiramente diferente: contar com erros de sorte.

Se você não está familiarizado com a frase, estamos aqui para explicar o que ela significa: ela é usada para contar segundos.

A ideia por trás disso é que adicionar a palavra _Mississipi_ a um número ao contar segundos em voz alta faz com que soem mais perto do relógio e, portanto, "um Mississipi, dois Mississipi, três Mississipi" levará aproximadamente três segundos reais! É frequentemente usado por crianças que brincam de esconde-esconde para garantir que o candidato faça uma contagem honesta.

Sua tarefa é muito simples aqui: escreva um programa que use um loop for para "contar de forma incorreta" para cinco. Depois de contar até cinco, o programa deve imprimir na tela a mensagem final "Pronto ou não, aqui vou eu!"

Use o esqueleto que fornecemos no editor.

**INFORMAÇÕES EXTRA**

Observe que o código no editor contém dois elementos que podem não estar totalmente claros para você no momento: a declaração import time e o método sleep(). Vamos falar sobre eles em breve.

Por enquanto, gostaríamos que você soubesse que importamos o módulo time e usamos o método sleep() para suspender a execução de cada função subsequente print() dentro do loop for por um segundo, para que a mensagem enviada para o console se assemelhe a uma contagem real. Não se preocupe, em breve você saberá mais sobre módulos e métodos.

**Saída prevista:**

              `1 Mississippi                                2 Mississippi                                3 Mississippi                                4 Mississippi                                5 Mississippi`
              
               
          
              

              Output
      

Console

Incompleta 3.2.8 As instruções break e continue

3.2.8 As instruções break e continue

Até agora, tratamos o corpo do loop como uma sequência indivisível e inseparável de instruções que são executadas completamente a cada turno do loop. No entanto, como desenvolvedor, você pode se deparar com as seguintes opções:

-   parece que é desnecessário continuar o loop como um todo; você deve se abster de executar o corpo do loop e ir além;
-   parece que você precisa iniciar a próxima curva do loop sem concluir a execução da curva atual.

O Python fornece duas instruções especiais para a implementação dessas duas tarefas. Digamos, por uma questão de precisão, que sua existência na linguagem não é necessária - um programador experiente é capaz de codificar qualquer algoritmo sem essas instruções. Essas adições, que não melhoram o poder expressivo da linguagem, mas simplificam o trabalho do desenvolvedor, às vezes são chamadas de **doce sintático**, ou açúcar sintático.

Essas duas instruções são:

-   break - sai do loop imediatamente e termina incondicionalmente a operação do loop; o programa começa a executar a instrução mais próxima após o corpo do loop;
-   continue - se comporta como se o programa tivesse chegado ao fim do corpo; o próximo turno é iniciado e a expressão de condição é testada imediatamente.

Ambas as palavras são **palavras-chave**.

Agora vamos mostrar dois exemplos simples para ilustrar como as duas instruções funcionam. Veja o código no editor. Execute o programa e analise a saída. Modifique o código e experimente.

Console

## As instruções break e continue: mais exemplos

Vamos voltar ao nosso programa que reconhece o maior entre os números inseridos. Vamos convertê-lo duas vezes, usando as instruções break e continue.

Analise o código e julgue se você usaria qualquer um deles.

A variação com break está aqui:

Console

Execute, teste e experimente.

E agora a variação com continue:

Console

Observe com cuidado, o usuário digita o primeiro número **antes** que o programa entre no loop while O número subsequente é inserido quando o programa já **está no loop**.

Novamente - execute o programa, teste-o e faça experiências com ele.

  

Concluída 3.2.9   **LAB**   A declaração break – Preso em um loop

---

3.2.9   **LAB**   A declaração break – Preso em um loop

---

## Cenário

A declaração break é usada para sair/encerrar um loop.

Projete um programa que use um loop while e solicite continuamente que o usuário insira uma palavra, a menos que o usuário insira "chupacabra" como a palavra de saída secreta, caso em que a mensagem "Você saiu do loop com sucesso". Deve ser impresso na tela, e o loop deve terminar.

Não imprima nenhuma das palavras inseridas pelo usuário. Use o conceito de execução condicional e a declaração break.

Console

  

Incompleta 3.2.10   **LAB**   A declaração _continue_ – o Feio Comedor de Vogais

---

3.2.10   **LAB**   A declaração _continue_ – o Feio Comedor de Vogais

---

## Cenário

A instrução continue é usada para ignorar o bloco atual e avançar para a próxima iteração, sem executar as instruções dentro do loop.

Ele pode ser usado com loops while e for.

Sua tarefa aqui é muito especial: você deve criar um comedor de vogal! Escreva um programa que use:

-   um loop for
-   o conceito de execução condicional (_if-elif-else_)
-   a declaração continue.

Seu programa deve:

-   peça ao usuário para inserir uma palavra;
-   use user_word = user_word.upper() para converter em maiúsculas a palavra inserida pelo usuário; falaremos sobre métodos de **string o método** top upper() muito em breve - não se preocupe;
-   use execução condicional e a declaração continue para "consumir" as seguintes vogais _A_, _E_, _I_, _O_, _U_ da palavra inserida;
-   imprima as letras não consumidas na tela, cada uma delas em uma linha separada.

Teste seu programa com os dados que fornecemos para você.

  

## Dados de teste:

**Exemplo de entrada:**

              `Gregory`
          
              

      

**Saída prevista:**

              `G                                R                                G                                R                                Y`
          
              

              Output
      

**Exemplo de entrada:**

              `abstemious`
          
              

      

**Saída prevista:**

              `B                                S                                T                                M                                S`
          
              

              Output
      

**Exemplo de entrada:**

              `IOUEA`
          
              

      

**Saída prevista:**

               
          
              

              Output
      

Console

  

Concluída 3.2.11   **LAB**   A declaração _continue_ – o Belo Comedor de Vogais

---

3.2.11   **LAB**   A declaração _continue_ – o Belo Comedor de Vogais

---

## Cenário

Sua tarefa aqui é ainda mais especial do que antes: você deve reprojetar o (feio) comedor de vogal do laboratório anterior e criar um melhor (bonito) comedor de vogal! Escreva um programa que use:

-   um loop for
-   o conceito de execução condicional (_if-elif-else_)
-   a declaração continue.

Seu programa deve:

-   peça ao usuário para inserir uma palavra;
-   use user_word = user_word.upper() para converter em maiúsculas a palavra inserida pelo usuário; falaremos sobre **métodos de string** e o método upper() muito em breve - não se preocupe;
-   use execução condicional e a declaração continue para "consumir" as seguintes vogais _A_, _E_, _I_, _O_, _U_ da palavra inserida;
-   atribua as letras não consumidas à variável word_without_vowels e imprima a variável na tela.

Veja o código no editor. Criamos word_without_vowels e atribuímos uma string vazia a ela. Use a operação de concatenação para pedir ao Python que combine letras selecionadas em uma sequência mais longa durante as voltas de loop subsequentes e atribua-a à variável word_without_vowels.

Teste seu programa com os dados que fornecemos para você.

  

## Dados de teste:

**Exemplo de entrada:**

              `Gregory`
          
              

      

**Saída prevista:**

              `GRGRY`
          
              

              Output
      

**Exemplo de entrada:**

              `abstemious`
          
              

      

**Saída prevista:**

              `BSTMS`
          
              

              Output
      

**Exemplo de entrada:**

              `IOUEA`
          
              

      

**Saída prevista:**

               
          
              

              Output
      

Console

Concluída 3.2.12 O loop while e o ramo else

3.2.12 O loop while e o ramo else

Ambos os loops, while e for, têm um recurso interessante (e raramente usado).

Mostraremos como funciona. Tente julgar por si mesmo se é utilizável e se você pode viver sem ela ou não.

Em outras palavras, tente se convencer se o recurso é valioso e útil ou se é apenas um recurso sintático.

Dê uma olhada no snippet no editor. Há algo de estranho no final - a palavra-chave else.

Como você pode ter suspeitado, **os loops também podem ter o ramo else, como os ifs**.

O ramo else do loop **sempre é executada uma vez, independentemente de o loop ter entrado em seu corpo ou não**.

Você consegue adivinhar o resultado? Execute o programa para verificar se você estava certo.

Console

Modifique o snippet um pouco para que o loop não tenha chance de executar seu corpo sequer uma vez:

Console

A condição do while é False no início. Você consegue vê-la?

Execute e teste o programa e verifique se o ramo else foi executado ou não.

Concluída 3.2.13 O loop for e o ramo else

3.2.13 O loop for e o ramo else

se os loops for se comportarem de forma um pouco diferente - dê uma olhada no snippet no editor e execute-o.

Console

A saída pode ser um pouco surpreendente.

A variável i mantém seu último valor.

Modifique um pouco o código para realizar mais uma experiência.

Console

Você consegue adivinhar o resultado?

O corpo do loop não será executado aqui. Nota: atribuímos a variável i antes do loop.

Execute o programa e verifique sua saída.

Quando o corpo do loop não é executado, a variável de controle retém o valor que tinha antes do loop.

Nota: **se a variável de controle não existir antes do início do loop, ela não existirá quando a execução atingir a filial do resto** else.

Como você se sente sobre a variant do else?

Em breve, falaremos sobre outros tipos de variáveis. Nossas variáveis atuais podem **armazenar apenas um valor de cada** vez, mas há variáveis que podem fazer muito mais: elas podem **armazenar quantos valores você quiser**. Mas vamos fazer alguns laboratórios, primeiro.

  

Concluída 3.2.14   **LAB**   Essenciais do loop _while_

---

3.2.14   **LAB**   Essenciais do loop _while_

---

## Cenário

Ouça esta história: um garoto e seu pai, um programador de computador, estão jogando com blocos de madeira. Eles estão construindo uma pirâmide.

A pirâmide deles é um pouco esquisita, pois na verdade é uma parede em forma de pirâmide - é plana. A pirâmide é empilhada de acordo com um princípio simples: cada camada inferior contém um bloco a mais do que a camada acima.

A figura ilustra a regra usada pelos construtores:

  

![](https://skillsforall.com/content/pe1/1.0/m3/course/pt-BR/assets/3fe9e03670b96fc65999f8d7ba1a478ac1812790.png)

Sua tarefa é escrever um programa que lê o número de blocos que os construtores têm e gera a altura da pirâmide que pode ser construída usando esses blocos.

Nota: a altura é medida pelo número de **camadas totalmente concluídas**; se os construtores não tiverem um número suficiente de blocos e não puderem concluir a próxima camada, eles terminarão seu trabalho imediatamente.

Teste seu código usando os dados que fornecemos.

  

  

Concluída 3.2.15   **LAB**   A hipótese de Collatz

---

### 3.2.15   **LAB**   A hipótese de Collatz

---

## Cenário

Em 1937, um matemático alemão chamado Lothar Collatz formulou uma hipótese intrigante (ainda não comprovada) que pode ser descrita da seguinte forma:

1.  pegue qualquer número inteiro diferente de zero e diferente de zero e nomeie-o como c0;
2.  se for par, avalie um novo c0 como c0 ÷ 2;
3.  caso contrário, se for ímpar, avalie um novo c0 como 3 × c0 + 1;
4.  se c0 ≠ 1 , volte ao ponto 2.

A hipótese diz que, independentemente do valor inicial de c0, ela sempre vai para 1.

Obviamente, é uma tarefa extremamente complexa usar um computador para provar a hipótese de qualquer número natural (pode até exigir inteligência artificial), mas você pode usar o Python para verificar alguns números individuais. Talvez você até encontre aquele que refutaria a hipótese.

Escreva um programa que leia um número natural e execute as etapas acima, desde que c0 permaneça diferente de 1. Também queremos que você conte as etapas necessárias para atingir o objetivo. Seu código deve gerar todos os valores intermediários de c0 também.

Dica: a parte mais importante do problema é como transformar a ideia de Collatz em um loop while - essa é a chave para o sucesso.

Teste seu código usando os dados que fornecemos.

```python

# hipotese de collatz  
etapas = 0  
numero_teste = int(input("Teste a hipotese de Lothar Collatz com o seu nûmero: "))  

#eu nao esperava, mas esse exercicio pediu um if dentro do if
if numero_teste == 1:  
print("começe com um número inicial diferente de 1")  
else:  
while numero_teste !=1:  
etapas += 1  
if numero_teste % 2 == 0:  
numero_teste /= 2  
else:  
numero_teste = 3* numero_teste + 1  
#para nao dar numeros float eu pedi print + int
print(int(numero_teste))  
print("o numero de etapas foi:", etapas)

```

---

**3.2.16 RESUMO DA SEÇÃO**

---

---

**3.2.16 RESUMO DA SEÇÃO**

---

1. Existem dois tipos de loops no Python: while e for:

-   o loop while executa uma declaração ou um conjunto de declarações desde que uma condição booleana especificada seja verdadeira, por exemplo:

              `# Exemplo 1                                while True:                                    print("Preso em um loop infinito.")                                                # Exemplo 2                                counter = 5                                while counter > 2:                                    print(counter)                                    counter -= 1`
              
               
          
              

      

-   o loop for executa um conjunto de instruções muitas vezes; é usado para iterar em uma sequência (por exemplo, uma lista, um dicionário, uma tupla ou um conjunto - você aprenderá sobre eles em breve) ou outros objetos iteráveis (por exemplo, sequências de caracteres). Você pode usar o loop for para fazer iterações em uma sequência de números usando a função range integrada. Veja os exemplos abaixo:

              `# Exemplo 1                                word = "Python"                                for letter in word:                                    print(letter, end="*")                                                # Exemplo 2                                for i in range(1, 10):                                    if i % 2 == 0:                                        printprint(i)`
              
               
          
              

      

2. Você pode usar as instruções break e continue para alterar o fluxo de um loop:

-   Você usa break para sair de um loop, por exemplo:

              `text = "OpenEDG Python Institute"                                for letter in text:                                    if letter == "P":                                        break                                    print(letter, end="")`
              
               
          
              

      

-   Você usa continue para ignorar a iteração atual e continuar com a próxima iteração, por exemplo:

              `text = "pyxpyxpyx                                for letter in text:                                    if letter == "x":                                        continue                                    print(letter, end="")`
              
               
          
              

      

3. Os loops while e for também podem ter uma cláusula else em Python. A cláusula else é executada depois que o loop termina sua execução, desde que não tenha sido finalizada por break, por exemplo:

              `n = 0                                                while n != 3:                                    print(n)                                    n += 1                                else:                                    print(n, "else")                                                print()                                                for i in range(0, 3):                                    print(i)                                else:                                    print(i, "else")`
              
               
          
              

      

4. A função range() gera uma sequência de números. Ele aceita números inteiros e retorna objetos de intervalo. A sintaxe de range() tem a seguinte aparência: range(start, stop, step), em que:

-   start é um parâmetro opcional que especifica o número inicial da sequência (0 por padrão)
-   stop é um parâmetro opcional que especifica o fim da sequência gerada (não está incluída),
-   e step é um parâmetro opcional que especifica a diferença entre os números na sequência (1 por padrão).

Exemplo de código:

              `for i in range(3):                                    print(i, end=" ")  # Outputs: 0 1 2                                                for i in range(6, 1, -2):                                    print(i, end=" ")  # Outputs: 6, 4, 2`

[[0 - VAULT/1 NOTAS LITERAIS/ANELO/LATAM 2023 - 3.1 Section 3 - Lógica e operações de bit em Python\|LATAM 2023 - 3.1 Section 3 - Lógica e operações de bit em Python]]
